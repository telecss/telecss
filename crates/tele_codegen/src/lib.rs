#![warn(missing_docs)]
#![deny(unused_imports)]
#![deny(unused_variables)]

//! A CSS code generator that generates CSS code from the AST generated by tele_parser

use std::error::Error;
use std::fmt::Write;
use tele_parser::{
  AstType, AtRuleNode, DeclarationNode, RuleSetNode, StatementNode, StyleSheetNode,
};

pub trait CodeGenerator {
  fn generate(&mut self, ast: AstType) -> Result<(), Box<dyn Error>> {
    self.gen_ss_node(&*ast.borrow())
  }

  fn gen_ss_node(&mut self, ss_node: &StyleSheetNode) -> Result<(), Box<dyn Error>>;
  fn gen_rule_set_node(&mut self, rule_set_node: &RuleSetNode) -> Result<(), Box<dyn Error>>;
  fn gen_at_rule_node(&mut self, at_rule_node: &AtRuleNode) -> Result<(), Box<dyn Error>>;
  fn gen_decl_node(&mut self, decl_node: &DeclarationNode) -> Result<(), Box<dyn Error>>;

  fn gen_statements(&mut self, statements: &Vec<StatementNode>) -> Result<(), Box<dyn Error>> {
    for stat in statements {
      match stat {
        StatementNode::AtRule(node) => self.gen_at_rule_node(&*node.borrow_mut())?,
        StatementNode::RuleSet(node) => self.gen_rule_set_node(&*node.borrow_mut())?,
      }
    }

    Ok(())
  }
}

pub struct Codegen<'a, W: Write> {
  css: &'a mut W,
  line: usize,
  column: usize,
  indent: usize,
  indent_level: usize,
}

impl<'a, W: Write> Codegen<'a, W> {
  pub fn new(writer: &'a mut W) -> Self {
    Codegen {
      css: writer,
      line: 0,
      column: 1,
      indent: 2,
      indent_level: 0,
    }
  }

  fn new_line(&mut self) -> Result<(), Box<dyn Error>> {
    self.line += 1;
    self.css.write_char('\n')?;
    for _ in 0..self.indent_level * self.indent {
      self.css.write_char(' ')?;
    }

    Ok(())
  }

  fn indent(&mut self) {
    self.indent_level += 1;
  }

  fn de_indent(&mut self) {
    self.indent_level -= 1;
  }
}

impl<'a, W: Write> CodeGenerator for Codegen<'a, W> {
  fn gen_ss_node(&mut self, ss_node: &StyleSheetNode) -> Result<(), Box<dyn Error>> {
    self.gen_statements(&ss_node.statements)
  }
  fn gen_rule_set_node(&mut self, rule_set_node: &RuleSetNode) -> Result<(), Box<dyn Error>> {
    self.css.write_str(&rule_set_node.prelude)?;
    self.css.write_str(" {")?;
    self.indent();

    for decl in &rule_set_node.declarations {
      self.new_line()?;
      self.gen_decl_node(&*decl.borrow())?;
    }

    self.de_indent();
    self.new_line()?;
    self.css.write_char('}')?;

    Ok(())
  }

  fn gen_at_rule_node(&mut self, at_rule_node: &AtRuleNode) -> Result<(), Box<dyn Error>> {
    self.css.write_char('@')?;
    self.css.write_str(&at_rule_node.name)?;
    self.css.write_char(' ')?;
    self.css.write_str(&at_rule_node.prelude)?;

    if at_rule_node.block.len() > 0 {
      self.css.write_char('{')?;
      self.indent();
      self.new_line()?;
      self.gen_statements(&at_rule_node.block)?;
      self.de_indent();
      self.new_line()?;
      self.css.write_char('}')?;
    } else {
      self.css.write_char(';')?;
    }

    Ok(())
  }

  fn gen_decl_node(&mut self, decl_node: &DeclarationNode) -> Result<(), Box<dyn Error>> {
    self.css.write_str(&decl_node.name)?;
    self.css.write_str(": ")?;
    self.css.write_str(&decl_node.value)?;

    if decl_node.important {
      self.css.write_str(" !important;")?;
    } else {
      self.css.write_char(';')?;
    }

    Ok(())
  }
}
